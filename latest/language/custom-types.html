<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom Types - Rust for C#/.NET Developers</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../license.html">License</a></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../language/index.html"><strong aria-hidden="true">2.</strong> Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language/scalar-types.html"><strong aria-hidden="true">2.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="../language/strings.html"><strong aria-hidden="true">2.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../language/structured-types.html"><strong aria-hidden="true">2.3.</strong> Structured Types</a></li><li class="chapter-item expanded "><a href="../language/custom-types.html" class="active"><strong aria-hidden="true">2.4.</strong> Custom Types</a></li><li class="chapter-item expanded "><a href="../language/local-functions.html"><strong aria-hidden="true">2.5.</strong> Local Functions</a></li><li class="chapter-item expanded "><a href="../language/lambda-and-closures.html"><strong aria-hidden="true">2.6.</strong> Lambda and Closures</a></li><li class="chapter-item expanded "><a href="../language/variables.html"><strong aria-hidden="true">2.7.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../language/namespaces.html"><strong aria-hidden="true">2.8.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../language/equality.html"><strong aria-hidden="true">2.9.</strong> Equality</a></li><li class="chapter-item expanded "><a href="../language/generics.html"><strong aria-hidden="true">2.10.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../language/polymorphism.html"><strong aria-hidden="true">2.11.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../language/inheritance.html"><strong aria-hidden="true">2.12.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../language/exception-handling.html"><strong aria-hidden="true">2.13.</strong> Exception Handling</a></li><li class="chapter-item expanded "><a href="../language/nullability-and-optionality.html"><strong aria-hidden="true">2.14.</strong> Nullability and Optionality</a></li><li class="chapter-item expanded "><a href="../language/discards.html"><strong aria-hidden="true">2.15.</strong> Discards</a></li><li class="chapter-item expanded "><a href="../language/conversion-and-casting.html"><strong aria-hidden="true">2.16.</strong> Conversion and Casting</a></li><li class="chapter-item expanded "><a href="../language/operator-overloading.html"><strong aria-hidden="true">2.17.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="../language/documentation-comments.html"><strong aria-hidden="true">2.18.</strong> Documentation Comments</a></li></ol></li><li class="chapter-item expanded "><a href="../memory-management/index.html"><strong aria-hidden="true">3.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="../resource-management/index.html"><strong aria-hidden="true">4.</strong> Resource Management</a></li><li class="chapter-item expanded "><a href="../threading/index.html"><strong aria-hidden="true">5.</strong> Threading</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../threading/synchronization.html"><strong aria-hidden="true">5.1.</strong> Synchronization</a></li><li class="chapter-item expanded "><a href="../threading/producer-consumer.html"><strong aria-hidden="true">5.2.</strong> Producer-Consumer</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/index.html"><strong aria-hidden="true">6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../benchmarking/index.html"><strong aria-hidden="true">7.</strong> Benchmarking</a></li><li class="chapter-item expanded "><a href="../logging-and-tracing/index.html"><strong aria-hidden="true">8.</strong> Logging and Tracing</a></li><li class="chapter-item expanded "><a href="../conditional-compilation/index.html"><strong aria-hidden="true">9.</strong> Conditional Compilation</a></li><li class="chapter-item expanded "><a href="../environment-and-configuration/index.html"><strong aria-hidden="true">10.</strong> Environment and Configuration</a></li><li class="chapter-item expanded "><a href="../linq/index.html"><strong aria-hidden="true">11.</strong> LINQ</a></li><li class="chapter-item expanded "><a href="../meta-programming/index.html"><strong aria-hidden="true">12.</strong> Meta Programming</a></li><li class="chapter-item expanded "><a href="../asynchronous-programming/index.html"><strong aria-hidden="true">13.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../project-structure/index.html"><strong aria-hidden="true">14.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="../compilation-and-building/index.html"><strong aria-hidden="true">15.</strong> Compilation and Building</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for C#/.NET Developers</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/microsoft/rust-for-dotnet-devs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/microsoft/rust-for-dotnet-devs/edit/main/src/language/custom-types.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<p>Rust doesn't have classes. It only has structures or <code>struct</code>.</p>
<h2 id="records"><a class="header" href="#records">Records</a></h2>
<p>Rust doesn't have any construct for authoring records, neither like <code>record struct</code> nor <code>record class</code> in C#.</p>
<h2 id="structures-struct"><a class="header" href="#structures-struct">Structures (<code>struct</code>)</a></h2>
<p>Structures in Rust and C# share a few similarities:</p>
<ul>
<li>
<p>They are defined with the <code>struct</code> keyword, but in Rust, <code>struct</code> simply
defines the data/fields. The behavioural aspects in terms of functions and
methods, are defined separately in an <em>implementation block</em> (<code>impl</code>).</p>
</li>
<li>
<p>They can implement multiple traits in Rust just as they can implement
multiple interfaces in C#.</p>
</li>
<li>
<p>They cannot be sub-classed.</p>
</li>
<li>
<p>They are allocated on stack by default, unless:</p>
<ul>
<li>In .NET, boxed or cast to an interface.</li>
<li>In Rust, wrapped in a smart pointer like <code>Box</code>, <code>Rc</code>/<code>Arc</code>.</li>
</ul>
</li>
</ul>
<p>In C#, a <code>struct</code> is a way to model a <em>value type</em> in .NET, which is typically
some domain-specific primitive or compound with value equality semantics. In
Rust, a <code>struct</code> is the primary construct for modeling any data structure (the
other being an <code>enum</code>).</p>
<p>A <code>struct</code> (or <code>record struct</code>) in C# has copy-by-value and value equality
semantics by default, but in Rust, this requires just one more step using <a href="https://doc.rust-lang.org/stable/reference/attributes/derive.html">the
<code>#derive</code> attribute</a> and listing the traits to be implemented:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq, Hash)]
struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>Value types in C#/.NET are usually designed by a developer to be immutable.
It's considered best practice speaking semantically, but the language does not
prevent designing a <code>struct</code> that makes destructive or in-place modifications.
In the Rust, it's the same. A type has to be consciously developed to be
immutable.</p>
<p>Since Rust doesn't have classes and consequently type hierarchies based on
sub-classing, shared behaviour is achieved via traits and generics and
polymorphism via virtual dispatch using <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">trait objects</a>.</p>
<p>Consider following <code>struct</code> representing a rectangle in C#:</p>
<pre><code class="language-c#">struct Rectangle
{
    public Rectangle(int x1, int y1, int x2, int y2) =&gt;
        (X1, Y1, X2, Y2) = (x1, y1, x2, y2);

    public int X1 { get; }
    public int Y1 { get; }
    public int X2 { get; }
    public int Y2 { get; }

    public int Length =&gt; Y2 - Y1;
    public int Width =&gt; X2 - X1;

    public (int, int) TopLeft =&gt; (X1, Y1);
    public (int, int) BottomRight =&gt; (X2, Y2);

    public int Area =&gt; Length * Width;
    public bool IsSquare =&gt; Width == Length;

    public override string ToString() =&gt; $&quot;({X1}, {Y1}), ({X2}, {Y2})&quot;;
}
</code></pre>
<p>The equivalent in Rust would be:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(dead_code)]

<span class="boring">fn main() {
</span>struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    pub fn x1(&amp;self) -&gt; i32 { self.x1 }
    pub fn y1(&amp;self) -&gt; i32 { self.y1 }
    pub fn x2(&amp;self) -&gt; i32 { self.x2 }
    pub fn y2(&amp;self) -&gt; i32 { self.y2 }

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn top_left(&amp;self) -&gt; (i32, i32) {
        (self.x1, self.y1)
    }

    pub fn bottom_right(&amp;self) -&gt; (i32, i32) {
        (self.x2, self.y2)
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }

    pub fn is_square(&amp;self)  -&gt; bool {
        self.width() == self.length()
    }
}

use std::fmt::*;

impl Display for Rectangle {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        write!(f, &quot;({}, {}), ({}, {})&quot;, self.x1, self.y2, self.x2, self.y2)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that a <code>struct</code> in C# inherits the <code>ToString</code> method from <code>object</code> and
therefore it <em>overrides</em> the base implementation to provide a custom string
representation. Since there is no inheritance in Rust, the way a type
advertises support for some <em>formatted</em> representation is by implementing the
<code>Display</code> trait. This then enables for an instance of the structure to
participate in formatting, such as shown in the call to <code>println!</code> below:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect = Rectangle::new(12, 34, 56, 78);
    println!(&quot;Rectangle = {rect}&quot;);
}</code></pre></pre>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>Rust doesn't have interfaces like those found in C#/.NET. It has <em>traits</em>,
instead. Similar to an interface, a trait represents an abstraction and its
members form a contract that must be fulfilled when implemented on a type.</p>
<p>Just the way interfaces can have default methods in C#/.NET (where a default
implementation body is provided as part of the interface definition), so can
traits in Rust. The type implementing the interface/trait can subsequently
provide a more suitable and/or optimized implementation.</p>
<p>C#/.NET interfaces can have all types of members, from properties, indexers,
events to methods, both static- and instance-based. Likewise, traits in Rust
can have (instance-based) method, associated functions (think static methods
in C#/.NET) and constants.</p>
<p>Apart from class hierarchies, interfaces are a core means of achieving
polymorphism via dynamic dispatch for cross-cutting abstractions. They enable
general-purpose code to be written against the abstractions represented by the
interfaces without much regard to the concrete types implementing them. The
same can be achieved with Rust's <em>trait objects</em> in a limited fashion. A trait
object is essentially a <em>v-table</em> (virtual table) identified with the <code>dyn</code>
keyword followed by the trait name, as in <code>dyn Shape</code> (where <code>Shape</code> is the
trait name). Trait objects always live behind a pointer, either a reference
(e.g. <code>&amp;dyn Shape</code>) or the heap-allocated <code>Box</code> (e.g. <code>Box&lt;dyn Shape&gt;</code>). This
is somewhat like in .NET, where an interface is a reference type such that a
value type cast to an interface is automatically boxed onto the managed heap.
The passing limitation of trait objects mentioned earler, is that the original
implementing type cannot be recovered. In other words, whereas it's quite
common to downcast or test an interface to be an instance of some other
interface or sub- or concrete type, the same is not possible in Rust (without
additional effort and support).</p>
<h2 id="enumeration-types-enum"><a class="header" href="#enumeration-types-enum">Enumeration types (<code>enum</code>)</a></h2>
<p>In C#, an <code>enum</code> is a value type that maps symbolic names to integral values:</p>
<pre><code class="language-c#">enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}
</code></pre>
<p>Rust has practically <em>identical</em> syntax for doing the same:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike in .NET, an instance of an <code>enum</code> type in Rust does not have any
pre-defined behaviour that's inherited. It cannot even participate in equality
checks as simple as <code>dow == DayOfWeek::Friday</code>. To bring it somewhat on par in
function with an <code>enum</code> in C#, use <a href="https://doc.rust-lang.org/stable/reference/attributes/derive.html">the <code>#derive</code> attribute</a> to
automatically have macros implement the commonly needed functionality:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug,     // enables formatting in &quot;{:?}&quot;
         Clone,     // required by Copy
         Copy,      // enables copy-by-value semantics
         Hash,      // enables hash-ability for use in map types
         PartialEq  // enables value equality (==)
)]
enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}

fn main() {
    let dow = DayOfWeek::Wednesday;
    println!(&quot;Day of week = {dow:?}&quot;);

    if dow == DayOfWeek::Friday {
        println!(&quot;Yay! It's the weekend!&quot;);
    }

    // coerce to integer
    let dow = dow as i32;
    println!(&quot;Day of week = {dow:?}&quot;);

    let dow = dow as DayOfWeek;
    println!(&quot;Day of week = {dow:?}&quot;);
}</code></pre></pre>
<p>As the example above shows, an <code>enum</code> can be coerced to its assigned integral
value, but the opposite is not possible as in C# (although that sometimes has
the downside in C#/.NET that an <code>enum</code> instance can hold an unrepresented
value). Instead, it's up to the developer to provide such a helper function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DayOfWeek {
    fn from_i32(n: i32) -&gt; Result&lt;DayOfWeek, i32&gt; {
        use DayOfWeek::*;
        match n {
            0 =&gt; Ok(Sunday),
            1 =&gt; Ok(Monday),
            2 =&gt; Ok(Tuesday),
            3 =&gt; Ok(Wednesday),
            4 =&gt; Ok(Thursday),
            5 =&gt; Ok(Friday),
            6 =&gt; Ok(Saturday),
            _ =&gt; Err(n)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>from_i32</code> function returns a <code>DayOfWeek</code> in a <code>Result</code> indicating success
(<code>Ok</code>) if <code>n</code> is valid. Otherwise it returns <code>n</code> as-is in a <code>Result</code>
indicating failure (<code>Err</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dow = DayOfWeek::from_i32(5);
println!(&quot;{dow:?}&quot;); // prints: Ok(Friday)

let dow = DayOfWeek::from_i32(50);
println!(&quot;{dow:?}&quot;); // prints: Err(50)
<span class="boring">}</span></code></pre></pre>
<p>There exist crates in Rust that can help with implementing such mapping from
integral types instead of having to code them manually.</p>
<p>An <code>enum</code> type in Rust can also serve as a way to design (discriminated) union
types, which allow different <em>variants</em> to hold data specific to each variant.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>This form of <code>enum</code> declaration does not exist in C#, but it can be emulated
with (class) records:</p>
<pre><code class="language-c#">var home = new IpAddr.V4(127, 0, 0, 1);
var loopback = new IpAddr.V6(&quot;::1&quot;);

abstract record IpAddr
{
    public sealed record V4(byte A, byte B, byte C, byte D): IpAddr;
    public sealed record V6(string Address): IpAddr;
}
</code></pre>
<p>The difference between the two is that the Rust definition produces a <em>closed
type</em> over the variants. In other words, the compiler knows that there will be
no other variants of <code>IpAddr</code> except <code>IpAddr::V4</code> and <code>IpAddr::V6</code>, and it can
use that knowledge to make stricter checks. For example, in a <code>match</code>
expression that's akin to C#'s <code>switch</code> expression, the Rust compiler will
fail code unless all variants are covered. In contrast, the emulation with C#
actually creates a class hierarchy (albeit very succinctly expressed) and
since <code>IpAddr</code> is an <em>abstract base class</em>, the set of all types it can
represent is unknown to the compiler.</p>
<h2 id="members"><a class="header" href="#members">Members</a></h2>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>Rust does not have any notion of constructors. Instead, you just write factory
functions that return an instance of the type. The factory functions can be
stand-alone or <em>associated functions</em> of the type. In C# terms, associated
functions are like have static methods on a type. Conventionally, if there is
just one factory function for a <code>struct</code>, it's named <code>new</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Since Rust functions (associated or otherwise) do not support overloading, the
factory functions have to be named uniquely. For example, below are some
examples of so-called constructors or factory functions available on <code>String</code>:</p>
<ul>
<li><code>String::new</code>: creates an empty string.</li>
<li><code>String::with_capacity</code>: creates a string with an initial buffer capacity.</li>
<li><code>String::from_utf8</code>: creates a string from bytes of UTF-8 encoded text.</li>
<li><code>String::from_utf16</code>: creates a string from bytes of UTF-16 encoded text.</li>
</ul>
<p>In the case of an <code>enum</code> type in Rust, the variants act as the constructors.
See <a href="#enumeration-types-enum">the section on enumeration types</a> for more.</p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://rust-lang.github.io/api-guidelines/predictability.html?highlight=new#constructors-are-static-inherent-methods-c-ctor">Constructors are static, inherent methods (C-CTOR)</a></p>
</li>
</ul>
<h3 id="methods-static--instance-based"><a class="header" href="#methods-static--instance-based">Methods (static &amp; instance-based)</a></h3>
<p>Like C#, Rust types (both <code>enum</code> and <code>struct</code>), can have static and
instance-based methods. In Rust-speak, a <em>method</em> is always instance-based and
is identified by the fact that its first parameter is named <code>self</code>. The <code>self</code>
parameter has no type annotation since it's always the type to which the
method belongs. A static method is called an <em>associated function</em>. In the
example below, <code>new</code> is an associated function and the rest (<code>length</code>, <code>width</code>
and <code>area</code>) are methods of the type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<p>Like in C#, a type in Rust can have constants. However, the most interesting
aspect to note is that Rust allows a type instance to be defined as a constant
too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

impl Point {
    const EMPTY: ZERO = Point { x: 0, y: 0 };
}
<span class="boring">}</span></code></pre></pre>
<p>In C#, the same would require a static read-only field:</p>
<pre><code class="language-c#">readonly record struct Point(int X, int Y)
{
    public static readonly Point Zero = new(0, 0);
}
</code></pre>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<p>Rust has no built-in support for type members to adverstise and fire events,
like C# has with the <code>event</code> keyword.</p>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>In C#, fields of a type are generally private. They are then
protected/encapsulated by property members with accessor methods (<code>get</code>, and
<code>set</code>) to read or write to those field. The accessor methods can contain extra
logic, for example, to either validate the value when being set or compute a
value when being read. Rust only has methods <a href="https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md#gettersetter-apis">where a getter is named after the
field (in Rust method names can share the same identifier as a field) and the
setter uses a <code>set_</code> prefix</a>.</p>
<p>Below is an example showing how property-like accessor methods typically look
for a type in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    // like property getters (each shares the same name as the field)

    pub fn x1(&amp;self) -&gt; i32 { self.x1 }
    pub fn y1(&amp;self) -&gt; i32 { self.y1 }
    pub fn x2(&amp;self) -&gt; i32 { self.x2 }
    pub fn y2(&amp;self) -&gt; i32 { self.y2 }

    // like property setters

    pub fn set_x1(&amp;mut self, val: i32) { self.x1 = val }
    pub fn set_y1(&amp;mut self, val: i32) { self.y1 = val }
    pub fn set_x2(&amp;mut self, val: i32) { self.x2 = val }
    pub fn set_y2(&amp;mut self, val: i32) { self.y2 = val }

    // like computed properties

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="extension-methods"><a class="header" href="#extension-methods">Extension Methods</a></h3>
<p>Extension methods in C# enable the developer to attach new statically-bound
methods to existing types, without needing to modify the original definition
of the type. In the following C# example, a new <code>Wrap</code> method is added to the
<code>StringBuilder</code> class <em>by extension</em>:</p>
<pre><code class="language-csharp">using System;
using System.Text;
using Extensions; // (1)

var sb = new StringBuilder(&quot;Hello, World!&quot;);
sb.Wrap(&quot;&gt;&gt;&gt; &quot;, &quot; &lt;&lt;&lt;&quot;); // (2)
Console.WriteLine(sb.ToString()); // Prints: &gt;&gt;&gt; Hello, World! &lt;&lt;&lt;

namespace Extensions
{
    static class StringBuilderExtensions
    {
        public static void Wrap(this StringBuilder sb,
                                string left, string right) =&gt;
            sb.Insert(0, left).Append(right);
    }
}
</code></pre>
<p>Note that for an extension method to become available (2), the namespace with
the type containing the extension method must be imported (1). Rust offers a
very similar facility via traits, called <em>extension traits</em>. The following
example in Rust is the equivalent of the C# example above; it extends <code>String</code>
with the method <code>wrap</code>:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)]

mod exts {
    pub trait StrWrapExt {
        fn wrap(&amp;mut self, left: &amp;str, right: &amp;str);
    }

    impl StrWrapExt for String {
        fn wrap(&amp;mut self, left: &amp;str, right: &amp;str) {
            self.insert_str(0, left);
            self.push_str(right);
        }
    }
}

fn main() {
    use exts::StrWrapExt as _; // (1)

    let mut s = String::from(&quot;Hello, World!&quot;);
    s.wrap(&quot;&gt;&gt;&gt; &quot;, &quot; &lt;&lt;&lt;&quot;); // (2)
    println!(&quot;{s}&quot;); // Prints: &gt;&gt;&gt; Hello, World! &lt;&lt;&lt;
}</code></pre></pre>
<p>Just like in C#, for the method in the extension trait to become available
(2), the extension trait muse be imported (1). Also note, the extension trait
identifier <code>StrWrapExt</code> can itself be discarded via <code>_</code> at the time of import
without affecting the availability of <code>wrap</code> for <code>String</code>.</p>
<h3 id="visibilityaccess-modifiers"><a class="header" href="#visibilityaccess-modifiers">Visibility/Access modifiers</a></h3>
<p>C# has a number of accessibility or visibility modifiers:</p>
<ul>
<li><code>private</code></li>
<li><code>protected</code></li>
<li><code>internal</code></li>
<li><code>protected internal</code> (family)</li>
<li><code>public</code></li>
</ul>
<p>In Rust, a compilation is built-up of a tree of modules where modules contain
and define <a href="https://doc.rust-lang.org/reference/items.html"><em>items</em></a> like types, traits, enums, constants and
functions. Almost everything is private by default. One exception is, for
example, <em>associated items</em> in a public trait, which are public by default.
This is similar to how members of a C# interface declared without any public
modifiers in the source code are public by default. Rust only has the <code>pub</code>
modifier to change the visibility with respect to the module tree. There
are variations of <code>pub</code> that change the scope of the public visibility:</p>
<ul>
<li><code>pub(self)</code></li>
<li><code>pub(super)</code></li>
<li><code>pub(crate)</code></li>
<li><code>pub(in PATH)</code></li>
</ul>
<p>For more details, see the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">Visibility and Privacy</a> section of The Rust
Reference.</p>
<p>The table below is an approximation of the mapping of C# and Rust modifiers:</p>
<div class="table-wrapper"><table><thead><tr><th>C#</th><th>Rust</th><th>Note</th></tr></thead><tbody>
<tr><td><code>private</code></td><td>(default)</td><td>See note 1.</td></tr>
<tr><td><code>protected</code></td><td>N/A</td><td>See note 2.</td></tr>
<tr><td><code>internal</code></td><td><code>pub(crate)</code></td><td></td></tr>
<tr><td><code>protected internal</code> (family)</td><td>N/A</td><td>See note 2.</td></tr>
<tr><td><code>public</code></td><td><code>pub</code></td><td></td></tr>
</tbody></table>
</div>
<ol>
<li>
<p>There is no keyword to denote private visibility; it's the default in Rust.</p>
</li>
<li>
<p>Since there are class-based type hierarchies in Rust, there is no
equivalent of <code>protected</code>.</p>
</li>
</ol>
<h3 id="mutability"><a class="header" href="#mutability">Mutability</a></h3>
<p>When designing a type in C#, it is the responsiblity of the developer to
decide whether the a type is mutable or immutable; whether it supports
destructive or non-destructive mutations. C# does support an immutable design
for types with a <em>positional record declaration</em> (<code>record class</code> or <code>readonly record struct</code>). In Rust, mutability is expressed on methods through the type
of the <code>self</code> parameter as shown in the example below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point { x: i32, y: i32 }

impl Point {
    pub fn new(x: i32, y: i32) -&gt; Self {
        Self { x, y }
    }

    // self is not mutable

    pub fn x(&amp;self) -&gt; i32 { self.x }
    pub fn y(&amp;self) -&gt; i32 { self.y }

    // self is mutable

    pub fn set_x(&amp;mut self, val: i32) { self.x = val }
    pub fn set_y(&amp;mut self, val: i32) { self.y = val }
}
<span class="boring">}</span></code></pre></pre>
<p>In C#, you can do non-destructive mutations using <code>with</code>:</p>
<pre><code class="language-c#">var pt = new Point(123, 456);
pt = pt with { X = 789 };
Console.WriteLine(pt.ToString()); // prints: Point { X = 789, Y = 456 }

readonly record struct Point(int X, int Y);
</code></pre>
<p>There is no <code>with</code> in Rust, but to emulate something similar in Rust, it has
to be baked into the type's design:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point { x: i32, y: i32 }

impl Point {
    pub fn new(x: i32, y: i32) -&gt; Self {
        Self { x, y }
    }

    pub fn x(&amp;self) -&gt; i32 { self.x }
    pub fn y(&amp;self) -&gt; i32 { self.y }

    // following methods consume self and return a new instance

    pub fn set_x(self, val: i32) -&gt; Self { Self::new(val, self.y) }
    pub fn set_y(self, val: i32) -&gt; Self { Self::new(self.x, val) }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Overloading</li>
<li>Extension methods (extension traits)</li>
<li>Builder pattern</li>
<li><code>System.Object</code> members:
<ul>
<li><code>Equals</code></li>
<li><code>ToString</code> (<code>Display</code>, <code>Debug</code>)</li>
<li><code>GetHashCode</code></li>
<li><code>GetType</code> (pattern-matching and enums)</li>
</ul>
</li>
<li>Newtype (primitive obsession)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language/structured-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../language/local-functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language/structured-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../language/local-functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
